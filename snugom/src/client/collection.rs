//! CollectionHandle - Type-safe accessor for CRUD operations on a single entity collection.
//!
//! This provides the Prisma-style API for simple operations:
//! ```ignore
//! let guild = snugom.guilds().get(&id).await?;
//! let guild = snugom.guilds().create(guild_data).await?;
//! let guilds = snugom.guilds().find_many(query).await?;
//! ```

use redis::aio::ConnectionManager;
use serde::{Serialize, de::DeserializeOwned};
use serde_json::Value;

use crate::{
    errors::RepoError,
    repository::{
        CreateResult, GetOrCreateResult, MutationPayloadBuilder, Repo, UpdatePatchBuilder, UpsertResult,
    },
    search::{SearchQuery, SearchResult},
    types::{EntityMetadata, SnugomModel},
};

/// Result of a bulk create operation.
#[derive(Debug, Clone)]
pub struct BulkCreateResult {
    /// Number of entities created
    pub count: u64,
    /// IDs of created entities
    pub ids: Vec<String>,
    /// Raw responses from Redis
    pub responses: Vec<Vec<Value>>,
}

/// Type-safe handle for CRUD operations on a single entity collection.
///
/// This struct provides the Prisma-style API for simple CRUD operations.
/// It owns a `Repo<T>` and a cloned `ConnectionManager`, allowing for
/// convenient method chaining without lifetime concerns.
///
/// # Example
/// ```ignore
/// // Get by ID
/// let guild = snugom.guilds().get(&id).await?;
///
/// // Create
/// let guild = snugom.guilds().create(guild_builder).await?;
///
/// // Query
/// let guilds = snugom.guilds().find_many(query).await?;
/// ```
pub struct CollectionHandle<T>
where
    T: SnugomModel,
{
    repo: Repo<T>,
    conn: ConnectionManager,
}

impl<T> CollectionHandle<T>
where
    T: SnugomModel,
{
    /// Create a new CollectionHandle with the given repo and connection.
    ///
    /// This is typically called via `Client::collection<T>()` or via
    /// named accessors generated by `#[derive(SnugomClient)]`.
    pub fn new(repo: Repo<T>, conn: ConnectionManager) -> Self {
        Self { repo, conn }
    }

    /// Get a mutable reference to the connection for advanced operations.
    pub fn connection_mut(&mut self) -> &mut ConnectionManager {
        &mut self.conn
    }

    /// Get a reference to the underlying repository.
    pub fn repo(&self) -> &Repo<T> {
        &self.repo
    }

    /// Get the Redis key for an entity by ID.
    ///
    /// This provides access to the key format derived from the entity's
    /// `#[snugom(collection, service)]` attributes without hardcoding.
    ///
    /// # Example
    /// ```ignore
    /// let key = snugom.auctions().entity_key("auction-123");
    /// conn.expire(&key, 3600).await?;
    /// ```
    pub fn entity_key(&self, id: &str) -> String {
        self.repo.entity_key(id)
    }

    /// Get a glob pattern matching all entities in this collection.
    ///
    /// Useful for test cleanup or batch operations like `KEYS` or `SCAN`.
    ///
    /// # Example
    /// ```ignore
    /// let pattern = snugom.guilds().collection_pattern();
    /// // Returns something like "snug:guild:guilds:*"
    /// let keys: Vec<String> = conn.keys(&pattern).await?;
    /// ```
    pub fn collection_pattern(&self) -> String {
        self.repo.collection_pattern()
    }

    /// Get a glob pattern matching all keys in this service.
    ///
    /// Useful for test cleanup of all service data (entities + auxiliary keys).
    ///
    /// # Example
    /// ```ignore
    /// let pattern = snugom.guilds().service_pattern();
    /// // Returns something like "snug:guild:*"
    /// let keys: Vec<String> = conn.keys(&pattern).await?;
    /// ```
    pub fn service_pattern(&self) -> String {
        self.repo.service_pattern()
    }
}

// ============ Single Record by ID ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned,
{
    /// Get entity by ID.
    ///
    /// Returns `None` if the entity doesn't exist.
    pub async fn get(&mut self, id: &str) -> Result<Option<T>, RepoError> {
        self.repo.get(&mut self.conn, id).await
    }

    /// Get entity by ID, returning an error if not found.
    ///
    /// This is equivalent to Prisma's `findUniqueOrThrow`.
    pub async fn get_or_error(&mut self, id: &str) -> Result<T, RepoError> {
        self.get(id).await?.ok_or(RepoError::NotFound {
            entity_id: Some(id.to_string()),
        })
    }

    /// Check if an entity exists by ID.
    pub async fn exists(&mut self, id: &str) -> Result<bool, RepoError> {
        self.repo.exists(&mut self.conn, id).await
    }

    /// Count all entities in the collection.
    pub async fn count(&mut self) -> Result<u64, RepoError> {
        self.repo.count(&mut self.conn).await
    }
}

// ============ Query-based Reads ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned + crate::search::SearchEntity,
{
    /// Find first entity matching query.
    ///
    /// Returns `None` if no entity matches.
    pub async fn find_first(&mut self, query: SearchQuery) -> Result<Option<T>, RepoError> {
        // Limit to 1 result
        let limited_query = SearchQuery {
            page: Some(1),
            page_size: Some(1),
            ..query
        };
        let result = self.repo.search_with_query(&mut self.conn, limited_query).await?;
        Ok(result.items.into_iter().next())
    }

    /// Find first entity matching query, returning an error if not found.
    ///
    /// This is equivalent to Prisma's `findFirstOrThrow`.
    pub async fn find_first_or_error(&mut self, query: SearchQuery) -> Result<T, RepoError> {
        self.find_first(query).await?.ok_or(RepoError::NotFound { entity_id: None })
    }

    /// Find all entities matching query (paginated).
    ///
    /// Returns a `SearchResult` containing the matching entities and pagination info.
    pub async fn find_many(&mut self, query: SearchQuery) -> Result<SearchResult<T>, RepoError> {
        self.repo.search_with_query(&mut self.conn, query).await
    }

    /// Count entities matching query.
    pub async fn count_where(&mut self, query: SearchQuery) -> Result<u64, RepoError> {
        let result = self.find_many(query).await?;
        Ok(result.total)
    }

    /// Check if any entity matches the query.
    pub async fn exists_where(&mut self, query: SearchQuery) -> Result<bool, RepoError> {
        let result = self.find_first(query).await?;
        Ok(result.is_some())
    }
}

// ============ Single Record Writes ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned,
{
    /// Create an entity from a builder.
    ///
    /// Returns the `CreateResult` containing the ID and raw responses.
    /// Use `create_and_get` if you need the full entity back.
    pub async fn create<B>(&mut self, builder: B) -> Result<CreateResult, RepoError>
    where
        B: MutationPayloadBuilder,
        B::Entity: EntityMetadata,
    {
        self.repo.create_with_conn(&mut self.conn, builder).await
    }

    /// Create an entity and return the full entity (Prisma-style).
    ///
    /// This is a convenience method that creates the entity and then fetches it.
    pub async fn create_and_get<B>(&mut self, builder: B) -> Result<T, RepoError>
    where
        B: MutationPayloadBuilder,
        B::Entity: EntityMetadata,
    {
        self.repo.create_and_get(&mut self.conn, builder).await
    }

    /// Update an entity by ID using a patch builder.
    ///
    /// Returns the raw responses from Redis.
    pub async fn update<B>(&mut self, builder: B) -> Result<Vec<Value>, RepoError>
    where
        B: UpdatePatchBuilder,
        B::Entity: EntityMetadata,
        T: EntityMetadata + Serialize,
    {
        self.repo
            .update_patch_with_conn(&mut self.conn, builder)
            .await
    }

    /// Update an entity and return the full updated entity.
    pub async fn update_and_get<B>(&mut self, id: &str, builder: B) -> Result<T, RepoError>
    where
        B: UpdatePatchBuilder,
        B::Entity: EntityMetadata,
        T: EntityMetadata + Serialize,
    {
        self.repo
            .update_patch_with_conn(&mut self.conn, builder)
            .await?;
        self.get_or_error(id).await
    }

    /// Delete an entity by ID.
    pub async fn delete(&mut self, id: &str) -> Result<(), RepoError> {
        self.repo.delete_with_conn(&mut self.conn, id, None).await?;
        Ok(())
    }

    /// Delete an entity by ID with optimistic concurrency check.
    pub async fn delete_with_version(
        &mut self,
        id: &str,
        expected_version: u64,
    ) -> Result<(), RepoError> {
        self.repo
            .delete_with_conn(&mut self.conn, id, Some(expected_version))
            .await?;
        Ok(())
    }
}

// ============ Bulk Operations ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned,
{
    /// Create multiple entities.
    ///
    /// Returns `BulkCreateResult` containing the count and IDs of created entities.
    pub async fn create_many<B>(&mut self, builders: Vec<B>) -> Result<BulkCreateResult, RepoError>
    where
        B: MutationPayloadBuilder,
        B::Entity: EntityMetadata,
    {
        let mut ids = Vec::with_capacity(builders.len());
        let mut responses = Vec::with_capacity(builders.len());

        for builder in builders {
            let result = self.repo.create_with_conn(&mut self.conn, builder).await?;
            ids.push(result.id);
            responses.push(result.responses);
        }

        Ok(BulkCreateResult {
            count: ids.len() as u64,
            ids,
            responses,
        })
    }

    /// Delete multiple entities by IDs.
    ///
    /// Returns the count of successfully deleted entities.
    pub async fn delete_many_by_ids(&mut self, ids: &[&str]) -> Result<u64, RepoError> {
        let mut deleted = 0u64;
        for id in ids {
            // Try to delete, but don't fail if entity doesn't exist
            match self.repo.delete_with_conn(&mut self.conn, id, None).await {
                Ok(_) => deleted += 1,
                Err(RepoError::NotFound { .. }) => {}
                Err(e) => return Err(e),
            }
        }
        Ok(deleted)
    }

    /// Update multiple entities by IDs using a function that generates patches.
    ///
    /// For each ID, calls the patch generator function and applies the resulting patch.
    /// Returns the count of successfully updated entities.
    ///
    /// # Example
    /// ```ignore
    /// let updated = users.update_many_by_ids(&["id1", "id2"], |id| {
    ///     User::patch_builder()
    ///         .entity_id(id)
    ///         .status("inactive".to_string())
    /// }).await?;
    /// ```
    pub async fn update_many_by_ids<B, F>(&mut self, ids: &[&str], patch_fn: F) -> Result<u64, RepoError>
    where
        B: UpdatePatchBuilder,
        B::Entity: EntityMetadata,
        T: EntityMetadata + Serialize,
        F: Fn(&str) -> B,
    {
        let mut updated = 0u64;
        for id in ids {
            let builder = patch_fn(id);
            match self.repo.update_patch_with_conn(&mut self.conn, builder).await {
                Ok(_) => updated += 1,
                Err(RepoError::NotFound { .. }) => {}
                Err(e) => return Err(e),
            }
        }
        Ok(updated)
    }
}

// ============ Query-based Bulk Operations ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned + crate::search::SearchEntity,
{
    /// Delete all entities matching the query.
    ///
    /// Returns the count of deleted entities.
    ///
    /// Note: This performs a search first to find matching IDs, then deletes them.
    /// For large result sets, consider pagination.
    pub async fn delete_many(&mut self, query: SearchQuery) -> Result<u64, RepoError> {
        // First, find all matching entities to get their IDs
        let result = self.repo.search_with_query(&mut self.conn, query).await?;

        // Delete each entity by ID
        let mut deleted = 0u64;
        for item in result.items {
            let id = T::get_id(&item);
            match self.repo.delete_with_conn(&mut self.conn, &id, None).await {
                Ok(_) => deleted += 1,
                Err(RepoError::NotFound { .. }) => {}
                Err(e) => return Err(e),
            }
        }

        Ok(deleted)
    }

    /// Update all entities matching the query using a patch generator function.
    ///
    /// Returns the count of successfully updated entities.
    ///
    /// Note: This performs a search first to find matching entities, then updates them.
    /// For large result sets, consider pagination.
    ///
    /// # Example
    /// ```ignore
    /// // Deactivate all users who haven't logged in recently
    /// let query = SearchQuery::new().filter("last_login".lt("2024-01-01"));
    /// let updated = users.update_many(query, |id| {
    ///     User::patch_builder()
    ///         .entity_id(id)
    ///         .status("inactive".to_string())
    /// }).await?;
    /// ```
    pub async fn update_many<B, F>(&mut self, query: SearchQuery, patch_fn: F) -> Result<u64, RepoError>
    where
        B: UpdatePatchBuilder,
        B::Entity: EntityMetadata,
        T: EntityMetadata + Serialize,
        F: Fn(&str) -> B,
    {
        // First, find all matching entities to get their IDs
        let result = self.repo.search_with_query(&mut self.conn, query).await?;

        // Update each entity by ID
        let mut updated = 0u64;
        for item in result.items {
            let id = T::get_id(&item);
            let builder = patch_fn(&id);
            match self.repo.update_patch_with_conn(&mut self.conn, builder).await {
                Ok(_) => updated += 1,
                Err(RepoError::NotFound { .. }) => {}
                Err(e) => return Err(e),
            }
        }

        Ok(updated)
    }
}

// ============ Upsert Operations ============

impl<T> CollectionHandle<T>
where
    T: SnugomModel + DeserializeOwned + EntityMetadata + Serialize,
{
    /// Upsert: creates if entity doesn't exist, updates if it does.
    ///
    /// This operation is atomic - the existence check and mutation happen in a single
    /// Redis Lua script call, preventing race conditions.
    pub async fn upsert<C, U>(
        &mut self,
        create_builder: C,
        update_builder: U,
    ) -> Result<UpsertResult, RepoError>
    where
        C: MutationPayloadBuilder,
        C::Entity: EntityMetadata,
        U: UpdatePatchBuilder,
        U::Entity: EntityMetadata,
    {
        self.repo
            .upsert(&mut self.conn, create_builder, update_builder)
            .await
    }

    /// Get or create: returns existing entity or creates it if it doesn't exist.
    ///
    /// This operation is atomic - the existence check and create happen in a single
    /// Redis Lua script call, preventing race conditions.
    ///
    /// Unlike `upsert`, if the entity exists it is returned as-is without modification.
    pub async fn get_or_create<C>(
        &mut self,
        create_builder: C,
    ) -> Result<GetOrCreateResult<T>, RepoError>
    where
        C: MutationPayloadBuilder,
        C::Entity: EntityMetadata,
    {
        self.repo
            .get_or_create(&mut self.conn, create_builder)
            .await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Note: These tests would require a real Redis connection
    // They serve as documentation of the expected API

    #[test]
    fn test_bulk_create_result_structure() {
        let result = BulkCreateResult {
            count: 3,
            ids: vec!["id1".to_string(), "id2".to_string(), "id3".to_string()],
            responses: vec![],
        };
        assert_eq!(result.count, 3);
        assert_eq!(result.ids.len(), 3);
    }
}
