# SnugOM Schema Versioning Implementation Plan

## Overview

Building a Prisma-like schema versioning and migration system for SnugOM that provides:
1. Automatic schema change detection (no manual version bumping)
2. Maximum code generation for migrations
3. Full SnugOM access during migration execution
4. Clean separation: migrations run BEFORE app, runtime just validates

## Design Philosophy

| Principle | Implementation |
|-----------|----------------|
| **No manual versioning** | CLI detects changes by comparing struct to snapshot |
| **Maximum auto-generation** | Generate as much migration code as possible |
| **Developer control** | Generated code is editable Rust |
| **Runtime stays dumb** | App validates schema, errors on mismatch, no migration logic |
| **Migrations run separately** | Like Prisma: `snugom migrate deploy` runs before app starts |

---

## Architecture

### Component Responsibilities

| Component | Responsibility |
|-----------|----------------|
| **`snugom migrate`** | Scan entities, detect changes, generate migrations, update source |
| **`snugom migrate deploy`** | Run migrations (transform documents in Redis) |
| **Derive macro** | Read `#[snugom(schema = N)]` (written by CLI), emit constant |
| **Runtime** | Compare document schema to compiled constant, error if mismatch |

### What Lives Where

| Artifact | Location | Committed to Git? |
|----------|----------|-------------------|
| Schema snapshots | `.snugom/schemas/*.json` | Yes |
| Migration code | `src/migrations/*.rs` | Yes |
| Schema version | `#[snugom(schema = N)]` in source | Yes (updated by CLI) |
| Document schema | `$.metadata.schema` in Redis | N/A (runtime data) |

---

## CLI: snugom

A dedicated CLI for SnugOM, separate from snug-api's CLI. Same conventions and framework.

### Location

```
cargo/crates/snugom/
├── src/
│   ├── bin/
│   │   └── snugom/
│   │       ├── main.rs
│   │       └── commands/
│   │           ├── mod.rs
│   │           ├── migrate.rs      # migrate, migrate deploy
│   │           ├── schema.rs       # schema status, schema diff
│   │           └── init.rs         # init
│   └── lib.rs
```

### Commands

```bash
# Initialize snugom in a project
snugom init

# Generate migration (detect changes, create snapshot, generate code)
snugom migrate --name <migration_name>

# Show schema status (distribution of versions in Redis)
snugom schema status [collection]

# Show what would be migrated
snugom schema diff [collection]

# Run pending migrations
snugom migrate deploy

# Mark migration as applied/rolled-back (for recovery)
snugom migrate resolve <migration_name> --applied|--rolled-back
```

---

## Workflow: Complete Example

### Step 1: Initialize Project

```bash
$ snugom init

Created:
  .snugom/config.toml
  .snugom/schemas/
  src/migrations/mod.rs

Add to your Cargo.toml:
  [dependencies]
  snugom = { path = "../snugom" }
```

**`.snugom/config.toml`:**
```toml
[snugom]
migrations_dir = "src/migrations"
schemas_dir = ".snugom/schemas"

[redis]
# Used by `snugom migrate deploy`
url = "${REDIS_URL}"
```

**`src/migrations/mod.rs`:**
```rust
// Auto-generated by snugom. Migrations are added here automatically.

use snugom::migration::MigrationRegistry;

pub fn register_all(registry: &mut MigrationRegistry) {
    // Migrations will be registered here
}
```

---

### Step 2: Define First Entity

```rust
// src/user/models/domain.rs
use snugom::prelude::*;

#[derive(SnugomEntity, Serialize, Deserialize)]
struct User {
    #[snugom(id)]
    user_id: String,

    #[snugom(filterable(tag))]
    name: String,

    #[snugom(filterable(tag))]
    email: String,
}

bundle! {
    service: "myapp",
    entities: {
        User => "users",
    }
}
```

---

### Step 3: Generate Initial Migration

```bash
$ snugom migrate --name init

Scanning SnugomEntity types...
  Found: User at src/user/models/domain.rs:4
    No previous snapshot exists

Creating initial snapshot...
  ✓ .snugom/schemas/user_v1.json

Updating source files...
  ✓ src/user/models/domain.rs (added schema = 1)

Generating migration...
  ✓ src/migrations/20241228_100000_init.rs

Updated src/migrations/mod.rs

Done! Review and commit:
  - .snugom/schemas/user_v1.json
  - src/user/models/domain.rs
  - src/migrations/20241228_100000_init.rs
  - src/migrations/mod.rs
```

**Source file after CLI update:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // <-- CLI inserted this
struct User {
    #[snugom(id)]
    user_id: String,
    // ...
}
```

**Snapshot (`.snugom/schemas/user_v1.json`):**
```json
{
  "entity": "User",
  "collection": "users",
  "schema": 1,
  "fields": [
    {
      "name": "user_id",
      "type": "String",
      "id": true
    },
    {
      "name": "name",
      "type": "String",
      "filterable": "tag"
    },
    {
      "name": "email",
      "type": "String",
      "filterable": "tag"
    }
  ],
  "relations": [],
  "indexes": ["name", "email"],
  "generated_at": "2024-12-28T10:00:00Z"
}
```

**Generated migration:**
```rust
// src/migrations/20241228_100000_init.rs
//
// Initial schema migration - establishes baseline
// Generated: 2024-12-28T10:00:00Z
//
// Entities:
//   - User (schema 1)
//
// This migration has no transforms because it's the initial schema.
// All documents created after this point will be at schema 1.

use snugom::migration::*;

pub fn register(registry: &mut MigrationRegistry) {
    registry.register_baseline::<crate::user::User>(1);
}
```

**Updated `src/migrations/mod.rs`:**
```rust
use snugom::migration::MigrationRegistry;

mod _20241228_100000_init;

pub fn register_all(registry: &mut MigrationRegistry) {
    _20241228_100000_init::register(registry);
}
```

---

### Step 4: Add an Optional Field

**Developer edits the struct:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // Still 1, CLI will update
struct User {
    #[snugom(id)]
    user_id: String,

    #[snugom(filterable(tag))]
    name: String,

    #[snugom(filterable(tag))]
    email: String,

    // NEW: Added avatar URL
    avatar_url: Option<String>,
}
```

**Run migrate:**
```bash
$ snugom migrate --name add_avatar

Scanning SnugomEntity types...
  Found: User at src/user/models/domain.rs:4
    Latest snapshot: v1
    Current struct: DIFFERS from v1

Detected changes:
  + avatar_url: Option<String>

Creating snapshot...
  ✓ .snugom/schemas/user_v2.json

Updating source files...
  ✓ src/user/models/domain.rs (schema 1 → 2)

Generating migration...
  ✓ src/migrations/20241228_110000_add_avatar.rs

  Migration type: AUTO-GENERATED (no manual edits needed)

    + avatar_url: Option<String> → defaults to null

Updated src/migrations/mod.rs

Done! Review and commit.
```

**Source file after:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]  // <-- CLI updated this
struct User {
    // ...
    avatar_url: Option<String>,
}
```

**Generated migration (fully auto-generated):**
```rust
// src/migrations/20241228_110000_add_avatar.rs
//
// Migration: add_avatar
// Generated: 2024-12-28T11:00:00Z
//
// Changes:
//   User (v1 → v2):
//     + avatar_url: Option<String>
//
// AUTO-GENERATED - no manual edits required

use snugom::migration::*;
use serde_json::json;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("users", 1, 2)
        .transform(|mut doc| {
            doc["avatar_url"] = json!(null);
            Ok(doc)
        })
    );
}
```

---

### Step 5: Complex Change - Split a Field

**Developer changes struct:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]  // Still 2, CLI will update
struct User {
    #[snugom(id)]
    user_id: String,

    // CHANGED: Split name into first/last
    #[snugom(filterable(tag))]
    first_name: String,

    #[snugom(filterable(tag))]
    last_name: String,

    #[snugom(filterable(tag))]
    email: String,

    avatar_url: Option<String>,
}
```

**Run migrate:**
```bash
$ snugom migrate --name split_name

Scanning SnugomEntity types...
  Found: User at src/user/models/domain.rs:4
    Latest snapshot: v2
    Current struct: DIFFERS from v2

Detected changes:
  - name: String (REMOVED)
  + first_name: String (ADDED, non-optional)
  + last_name: String (ADDED, non-optional)

⚠ Complex migration detected:
  - Removed: name (String)
  + Added: first_name (String, non-optional)
  + Added: last_name (String, non-optional)

Creating snapshot...
  ✓ .snugom/schemas/user_v3.json

Updating source files...
  ✓ src/user/models/domain.rs (schema 2 → 3)

Generating migration...
  ✓ src/migrations/20241228_120000_split_name.rs

  Migration type: STUB (implementation required)

Updated src/migrations/mod.rs

⚠ ACTION REQUIRED: Review and complete the migration at:
   src/migrations/20241228_120000_split_name.rs
```

**Generated migration (stub - implementation required):**
```rust
// src/migrations/20241228_120000_split_name.rs
//
// Migration: split_name
// Generated: 2024-12-28T12:00:00Z
//
// ⚠ IMPLEMENTATION REQUIRED
//
// Changes:
//   User (v2 → v3):
//     - name: String (removed)
//     + first_name: String (added, non-optional)
//     + last_name: String (added, non-optional)
//
// This migration requires custom logic. Implement the transform below.
// See: https://snugom.dev/migrations/complex for examples.

use snugom::migration::*;
use serde_json::{json, Value};

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("users", 2, 3)
        .transform(|mut doc| {
            // TODO: Implement your migration logic here
            //
            // You have access to:
            //   - doc: serde_json::Value (the full document)
            //   - doc.get("field") to read fields
            //   - doc["field"] = json!(value) to set fields
            //   - doc.as_object_mut().unwrap().remove("field") to remove fields
            //
            // Example (splitting a name field):
            //
            //   let name = doc.get("name").and_then(|v| v.as_str()).unwrap_or("");
            //   let parts: Vec<&str> = name.splitn(2, ' ').collect();
            //   doc["first_name"] = json!(parts.first().unwrap_or(&""));
            //   doc["last_name"] = json!(parts.get(1).unwrap_or(&""));
            //   doc.as_object_mut().unwrap().remove("name");

            todo!("Implement migration logic")
        })
        .rebuild_index()  // Index fields changed
    );
}
```

---

### Step 6: Deploy Migrations

```bash
$ snugom migrate deploy

Connecting to Redis...
  ✓ Connected to redis://localhost:6379

Checking schema distribution...
  users: v1 (5,000), v2 (3,000), v3 (0)

Migrations to run:
  [1] users: v1 → v2 (add_avatar) - 5,000 documents
  [2] users: v2 → v3 (split_name) - 8,000 documents

Proceed? [y/N]: y

[1/2] Running: users v1 → v2 (add_avatar)
      ████████████████████ 100% (5,000/5,000) - 2.1s
      Added avatar_url: null

[2/2] Running: users v2 → v3 (split_name)
      ████████████████████ 100% (8,000/8,000) - 3.8s
      Split name → first_name, last_name
      Rebuilding index...
      ✓ Index rebuilt

✓ Migration complete
  Documents migrated: 8,000
  Duration: 5.9s

Final state:
  users: v3 (8,000)
```

---

## Relation Migration Examples

### Example 1: Adding a Relation

**Use case:** Users now belong to an Organization

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct User {
    #[snugom(id)]
    user_id: String,
    name: String,
    email: String,
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // CLI will update to 2
struct User {
    #[snugom(id)]
    user_id: String,
    name: String,
    email: String,

    // NEW: User belongs to Organization
    #[snugom(relation(target = "organization", cascade = "detach"), filterable(tag))]
    organization_id: Option<String>,
}
```

**CLI output:**
```bash
$ snugom migrate --name add_org_relation

Detected changes:
  + organization_id: Option<String>
  + relation: belongs_to → organization (cascade: detach)
  + index field: organization_id (TAG)

Generated: src/migrations/20241228_130000_add_org_relation.rs
```

**Generated migration:**
```rust
// src/migrations/20241228_130000_add_org_relation.rs
//
// Migration: add_org_relation
// Generated: 2024-12-28T13:00:00Z
//
// Changes:
//   User (v1 → v2):
//     + organization_id: Option<String> (relation → organization)
//
// AUTO-GENERATED

use snugom::migration::*;
use serde_json::json;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("users", 1, 2)
        .transform(|mut doc| {
            // New optional relation field defaults to null
            doc["organization_id"] = json!(null);
            Ok(doc)
        })
        .add_index_field(IndexField {
            name: "organization_id",
            field_type: IndexType::Tag,
        })
        .rebuild_index()
    );
}
```

**Snapshot diff (user_v1.json → user_v2.json):**
```diff
  "fields": [
    { "name": "user_id", "type": "String", "id": true },
    { "name": "name", "type": "String" },
-   { "name": "email", "type": "String" }
+   { "name": "email", "type": "String" },
+   { "name": "organization_id", "type": "Option<String>", "filterable": "tag" }
  ],
- "relations": [],
+ "relations": [
+   {
+     "field": "organization_id",
+     "target": "organization",
+     "kind": "belongs_to",
+     "cascade": "detach"
+   }
+ ],
- "indexes": ["name", "email"]
+ "indexes": ["name", "email", "organization_id"]
```

**What `snugom migrate deploy` does:**
```bash
$ snugom migrate deploy

[1/1] Running: users v1 → v2 (add_org_relation)
      ████████████████████ 100% (10,000/10,000)

      Transformations:
        + organization_id: null (10,000 docs)

      Index changes:
        Dropping index idx:snug:myapp:users...
        Creating index with new field organization_id (TAG)...
        ✓ Index rebuilt

✓ Migration complete
```

**Redis changes:**
```
# Each document updated
JSON.SET snug:myapp:users:u_123 $.organization_id null
JSON.SET snug:myapp:users:u_123 $.metadata.schema 2

# Index rebuilt
FT.DROPINDEX idx:snug:myapp:users
FT.CREATE idx:snug:myapp:users ON JSON PREFIX 1 snug:myapp:users:
  SCHEMA
    $.name AS name TAG
    $.email AS email TAG
    $.organization_id AS organization_id TAG
```

---

### Example 2: Removing a Relation

**Use case:** Users no longer have Posts (removing has_many)

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]
struct User {
    #[snugom(id)]
    user_id: String,
    name: String,

    #[snugom(relation(target = "post", kind = "has_many", cascade = "delete"))]
    posts: RelationState<Vec<Post>>,
}

#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct Post {
    #[snugom(id)]
    post_id: String,
    title: String,

    #[snugom(relation(target = "user"), filterable(tag))]
    author_id: String,
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]  // CLI will update to 3
struct User {
    #[snugom(id)]
    user_id: String,
    name: String,
    // posts relation REMOVED
}

#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // CLI will update to 2
struct Post {
    #[snugom(id)]
    post_id: String,
    title: String,

    // No longer a relation, just a plain indexed field
    #[snugom(filterable(tag))]
    author_id: String,
}
```

**CLI output:**
```bash
$ snugom migrate --name remove_posts_relation

Detected changes:
  User (v2 → v3):
    - posts: RelationState<Vec<Post>> (has_many relation removed)
    - cascade: delete behavior removed

  Post (v1 → v2):
    ~ author_id: relation removed, field retained as plain TAG

Generated: src/migrations/20241228_140000_remove_posts_relation.rs

Note: Removing has_many relation does not delete existing Post documents.
      The author_id field is retained for querying.
```

**Generated migration:**
```rust
// src/migrations/20241228_140000_remove_posts_relation.rs
//
// Migration: remove_posts_relation
// Generated: 2024-12-28T14:00:00Z
//
// Changes:
//   User (v2 → v3):
//     - posts: RelationState<Vec<Post>> (removed)
//       Note: has_many relations are not stored in documents,
//             only cascade behavior changes
//
//   Post (v1 → v2):
//     ~ author_id: No longer a relation, remains as indexed field
//
// AUTO-GENERATED - no data transformation needed

use snugom::migration::*;

pub fn register(registry: &mut MigrationRegistry) {
    // User: Only metadata/behavior change, no data transformation
    registry.add(Migration::new("users", 2, 3)
        .metadata_only()  // No document changes, just bump schema
    );

    // Post: author_id stays as-is, just no longer treated as FK
    registry.add(Migration::new("posts", 1, 2)
        .metadata_only()  // No document changes, just bump schema
    );
}
```

**What changes:**
- `$.metadata.schema` bumped on all User and Post documents
- No field changes (relation metadata is not stored in documents)
- Cascade delete behavior no longer applies
- Indexes unchanged (author_id remains indexed)

---

### Example 3: Changing a Relation (Embedded → Separate Entity)

**Use case:** Guild membership changes from embedded array to separate entity

**Before (embedded members):**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(filterable(tag))]
    name: String,

    // Members embedded directly in document
    members: Vec<EmbeddedMember>,
}

#[derive(Serialize, Deserialize, Clone)]
struct EmbeddedMember {
    user_id: String,
    role: String,
    joined_at: i64,  // epoch millis
}
```

**Document in Redis (v1):**
```json
{
  "guild_id": "g_123",
  "name": "Awesome Guild",
  "members": [
    { "user_id": "u_1", "role": "admin", "joined_at": 1703980800000 },
    { "user_id": "u_2", "role": "member", "joined_at": 1703990800000 },
    { "user_id": "u_3", "role": "member", "joined_at": 1704000800000 }
  ],
  "metadata": { "schema": 1, "version": 1 }
}
```

**After (separate GuildMember entity):**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // CLI will update to 2
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(filterable(tag))]
    name: String,

    // Now a has_many relation to separate entities
    #[snugom(relation(target = "guild_member", kind = "has_many", cascade = "delete"))]
    members: RelationState<Vec<GuildMember>>,
}

// NEW entity
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct GuildMember {
    #[snugom(id)]
    member_id: String,

    #[snugom(relation(target = "guild"), filterable(tag))]
    guild_id: String,

    #[snugom(filterable(tag))]
    user_id: String,

    #[snugom(filterable(tag))]
    role: String,

    #[snugom(datetime(epoch_millis), sortable)]
    joined_at: DateTime<Utc>,
}

bundle! {
    service: "myapp",
    entities: {
        Guild => "guilds",
        GuildMember => "guild_members",  // NEW
    }
}
```

**CLI output:**
```bash
$ snugom migrate --name extract_guild_members

Scanning SnugomEntity types...
  Found: Guild at src/guild/models/domain.rs:4
    Latest snapshot: v1
    Current struct: DIFFERS from v1
  Found: GuildMember at src/guild/models/domain.rs:20
    No previous snapshot (NEW ENTITY)

Detected changes:
  Guild (v1 → v2):
    ~ members: Vec<EmbeddedMember> → RelationState<Vec<GuildMember>>
      ⚠ COMPLEX: Embedded data must be extracted to new entity

  GuildMember (NEW):
    + member_id: String (id)
    + guild_id: String (relation → guild)
    + user_id: String
    + role: String
    + joined_at: DateTime<Utc>

⚠ COMPLEX MIGRATION: Embedded to Entity extraction

  This requires:
    1. Creating new GuildMember entities from embedded data
    2. Removing embedded members array from Guild
    3. Creating index for GuildMember

Creating snapshots...
  ✓ .snugom/schemas/guild_v2.json
  ✓ .snugom/schemas/guild_member_v1.json

Updating source files...
  ✓ src/guild/models/domain.rs (Guild: schema 1 → 2)
  ✓ src/guild/models/domain.rs (GuildMember: added schema = 1)

Generating migration...
  ✓ src/migrations/20241228_150000_extract_guild_members.rs

  Migration type: COMPLEX (uses full SnugOM access)

⚠ ACTION REQUIRED: Review the migration at:
   src/migrations/20241228_150000_extract_guild_members.rs
```

**Generated migration (complex with full SnugOM access):**
```rust
// src/migrations/20241228_150000_extract_guild_members.rs
//
// Migration: extract_guild_members
// Generated: 2024-12-28T15:00:00Z
//
// ⚠ COMPLEX MIGRATION - Review carefully
//
// This migration extracts embedded data into separate entities.
//
// Changes:
//   Guild (v1 → v2):
//     - members: Vec<EmbeddedMember> (embedded array removed)
//     + members: RelationState<Vec<GuildMember>> (relation added)
//
//   GuildMember (NEW v1):
//     Created from extracted embedded data
//
// Data flow:
//   Guild.members[*] → GuildMember entities
//   Guild.members array → removed from document

use snugom::migration::*;
use snugom::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use chrono::{DateTime, Utc};
use uuid::Uuid;

// Import your entities
use crate::guild::{Guild, GuildMember};

pub fn register(registry: &mut MigrationRegistry) {
    registry.add_complex(ExtractGuildMembersMigration);
}

// Temporary struct to deserialize embedded member format
#[derive(Deserialize)]
struct EmbeddedMemberData {
    user_id: String,
    role: String,
    joined_at: i64,
}

struct ExtractGuildMembersMigration;

impl ComplexMigration for ExtractGuildMembersMigration {
    fn name(&self) -> &str {
        "extract_guild_members"
    }

    fn collections(&self) -> Vec<(&str, u32, u32)> {
        vec![
            ("guilds", 1, 2),       // Guild v1 → v2
            ("guild_members", 0, 1), // GuildMember NEW (0 = create)
        ]
    }

    async fn execute(&self, ctx: &mut MigrationContext) -> Result<MigrationStats, MigrationError> {
        let mut stats = MigrationStats::default();

        // Get repos - full SnugOM access!
        let member_repo: Repo<GuildMember> = ctx.repo();

        // Process guilds in batches
        let mut cursor = 0;
        loop {
            // Scan raw documents at schema v1
            let batch = ctx.scan_raw("guilds", cursor, 100, Some(1)).await?;

            for mut guild_doc in batch.documents {
                let guild_id = guild_doc["guild_id"]
                    .as_str()
                    .ok_or_else(|| MigrationError::InvalidDocument("missing guild_id".into()))?
                    .to_string();

                // Extract embedded members
                if let Some(members_array) = guild_doc.get("members").and_then(|v| v.as_array()) {
                    for member_value in members_array {
                        // Parse embedded member
                        let embedded: EmbeddedMemberData = serde_json::from_value(member_value.clone())
                            .map_err(|e| MigrationError::InvalidDocument(e.to_string()))?;

                        // Create new GuildMember entity
                        let member = GuildMember {
                            member_id: format!("gm_{}", Uuid::new_v4()),
                            guild_id: guild_id.clone(),
                            user_id: embedded.user_id,
                            role: embedded.role,
                            joined_at: DateTime::from_timestamp_millis(embedded.joined_at)
                                .unwrap_or_else(Utc::now),
                        };

                        // Create using SnugOM repo
                        member_repo.create(&mut ctx.executor(), member).await
                            .map_err(|e| MigrationError::EntityCreation(e.to_string()))?;

                        stats.entities_created += 1;
                    }
                }

                // Update guild document: remove embedded members, bump schema
                if let Some(obj) = guild_doc.as_object_mut() {
                    obj.remove("members");
                }
                guild_doc["metadata"]["schema"] = json!(2);

                // Write updated guild
                ctx.update_raw("guilds", &guild_id, guild_doc).await?;
                stats.documents_migrated += 1;

                // Report progress
                ctx.progress(stats.documents_migrated, batch.total);
            }

            cursor = batch.cursor;
            if cursor == 0 {
                break;
            }
        }

        // Create index for new GuildMember collection
        ctx.create_index("guild_members", &[
            IndexField::tag("guild_id"),
            IndexField::tag("user_id"),
            IndexField::tag("role"),
            IndexField::numeric("joined_at"),
        ]).await?;

        Ok(stats)
    }
}
```

**What `snugom migrate deploy` does:**
```bash
$ snugom migrate deploy

[1/1] Running complex migration: extract_guild_members

      Scanning guilds at schema v1...
      Found 1,000 guilds to process

      Extracting members...
      ████████████████████ 100% (1,000/1,000 guilds)

      Summary:
        Guilds processed: 1,000
        Members extracted: 5,432

      Creating index for guild_members...
      ✓ Index created

✓ Migration complete
  Duration: 12.3s
```

**Before (Guild document v1):**
```json
{
  "guild_id": "g_123",
  "name": "Awesome Guild",
  "members": [
    { "user_id": "u_1", "role": "admin", "joined_at": 1703980800000 },
    { "user_id": "u_2", "role": "member", "joined_at": 1703990800000 }
  ],
  "metadata": { "schema": 1, "version": 1 }
}
```

**After (Guild document v2):**
```json
{
  "guild_id": "g_123",
  "name": "Awesome Guild",
  "metadata": { "schema": 2, "version": 2 }
}
```

**After (New GuildMember documents):**
```json
{
  "member_id": "gm_a1b2c3d4",
  "guild_id": "g_123",
  "user_id": "u_1",
  "role": "admin",
  "joined_at": 1703980800000,
  "metadata": { "schema": 1, "version": 1 }
}
```
```json
{
  "member_id": "gm_e5f6g7h8",
  "guild_id": "g_123",
  "user_id": "u_2",
  "role": "member",
  "joined_at": 1703990800000,
  "metadata": { "schema": 1, "version": 1 }
}
```

---

## Unique Constraint Migration Examples

### Example 4: Adding a Unique Constraint

**Use case:** Guild names must now be unique

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(filterable(tag))]
    name: String,  // Not unique
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // CLI will update to 2
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(unique, filterable(tag))]  // NEW: unique constraint
    name: String,
}
```

**CLI output:**
```bash
$ snugom migrate --name add_unique_guild_name

Detected changes:
  Guild (v1 → v2):
    ~ name: String (added unique constraint)

⚠ UNIQUE CONSTRAINT WARNING:
  Adding unique constraint to existing data requires validation.
  Existing duplicates will cause migration to fail.

  To check for duplicates before migrating:
    snugom schema validate guilds --field name

Generated: src/migrations/20241228_160000_add_unique_guild_name.rs

  Migration type: UNIQUE CONSTRAINT (requires validation)
```

**Generated migration:**
```rust
// src/migrations/20241228_160000_add_unique_guild_name.rs
//
// Migration: add_unique_guild_name
// Generated: 2024-12-28T16:00:00Z
//
// Changes:
//   Guild (v1 → v2):
//     ~ name: added unique constraint
//
// ⚠ UNIQUE CONSTRAINT: This migration will fail if duplicates exist.
//
// Run `snugom schema validate guilds --field name` to check for duplicates.

use snugom::migration::*;
use serde_json::Value;
use std::collections::HashMap;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("guilds", 1, 2)
        .validate_unique("name", false)  // false = case-sensitive
        .on_duplicate(DuplicateAction::Fail)  // Options: Fail, Skip, Rename
        .build_unique_index("name", false)
    );
}
```

**What `snugom migrate deploy` does:**
```bash
$ snugom migrate deploy

[1/1] Running: guilds v1 → v2 (add_unique_guild_name)

      Validating uniqueness of 'name' field...
      ████████████████████ 100% (10,000/10,000)

      ✓ All values unique

      Building unique index...
      ✓ Unique index created: snug:myapp:guilds:unique:name

      Updating schema version...
      ████████████████████ 100% (10,000/10,000)

✓ Migration complete
```

**If duplicates exist:**
```bash
$ snugom migrate deploy

[1/1] Running: guilds v1 → v2 (add_unique_guild_name)

      Validating uniqueness of 'name' field...
      ████████████████████ 100% (10,000/10,000)

      ✗ Found 3 duplicate values:

        "Awesome Guild":
          - g_123 (created: 2024-01-15)
          - g_789 (created: 2024-03-20)

        "Cool Squad":
          - g_234 (created: 2024-02-01)
          - g_567 (created: 2024-02-15)
          - g_890 (created: 2024-04-10)

      Migration aborted. Resolve duplicates before retrying.

      Options:
        1. Manually rename duplicates
        2. Use DuplicateAction::Rename in migration (appends suffix)
        3. Use DuplicateAction::Skip to exclude duplicates from index
```

---

### Example 5: Adding Case-Insensitive Unique

**Use case:** User slugs must be unique, case-insensitive

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct User {
    #[snugom(id)]
    user_id: String,

    #[snugom(filterable(tag))]
    slug: String,
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]  // CLI will update to 2
struct User {
    #[snugom(id)]
    user_id: String,

    #[snugom(unique(case_insensitive), filterable(tag))]
    slug: String,
}
```

**Generated migration:**
```rust
use snugom::migration::*;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("users", 1, 2)
        .validate_unique("slug", true)  // true = case-insensitive
        .on_duplicate(DuplicateAction::Fail)
        .build_unique_index("slug", true)  // Stores lowercase in index
    );
}
```

**Redis unique index (case-insensitive):**
```
# Hash key: {prefix}:{service}:{collection}:unique:{field}
# Hash field: lowercase(value) → entity_id

HSET snug:myapp:users:unique:slug "john-doe" "u_123"
HSET snug:myapp:users:unique:slug "jane-smith" "u_456"

# "JOHN-DOE" would conflict with "john-doe"
```

---

### Example 6: Adding Compound Unique Constraint

**Use case:** Projects must have unique names within each tenant

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1)]
struct Project {
    #[snugom(id)]
    project_id: String,

    #[snugom(filterable(tag))]
    tenant_id: String,

    #[snugom(filterable(tag))]
    name: String,
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 1, unique_together = ["tenant_id", "name"])]  // NEW
struct Project {
    #[snugom(id)]
    project_id: String,

    #[snugom(filterable(tag))]
    tenant_id: String,

    #[snugom(filterable(tag))]
    name: String,
}
```

**CLI output:**
```bash
$ snugom migrate --name add_tenant_project_unique

Detected changes:
  Project (v1 → v2):
    + unique_together: ["tenant_id", "name"]

Generated: src/migrations/20241228_170000_add_tenant_project_unique.rs
```

**Generated migration:**
```rust
use snugom::migration::*;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("projects", 1, 2)
        .validate_compound_unique(&["tenant_id", "name"], false)
        .on_duplicate(DuplicateAction::Fail)
        .build_compound_unique_index(&["tenant_id", "name"], false)
    );
}
```

**Redis compound unique index:**
```
# Hash key: {prefix}:{service}:{collection}:unique_compound:{field1}_{field2}
# Hash field: value1:value2 → entity_id

HSET snug:myapp:projects:unique_compound:tenant_id_name "acme:Alpha" "p_123"
HSET snug:myapp:projects:unique_compound:tenant_id_name "acme:Beta" "p_456"
HSET snug:myapp:projects:unique_compound:tenant_id_name "globex:Alpha" "p_789"

# "acme:Alpha" can only exist once, but "globex:Alpha" is allowed
```

---

### Example 7: Removing a Unique Constraint

**Use case:** Guild names no longer need to be unique

**Before:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(unique, filterable(tag))]
    name: String,
}
```

**After:**
```rust
#[derive(SnugomEntity, Serialize, Deserialize)]
#[snugom(schema = 2)]  // CLI will update to 3
struct Guild {
    #[snugom(id)]
    guild_id: String,

    #[snugom(filterable(tag))]  // unique removed
    name: String,
}
```

**Generated migration:**
```rust
use snugom::migration::*;

pub fn register(registry: &mut MigrationRegistry) {
    registry.add(Migration::new("guilds", 2, 3)
        .drop_unique_index("name")
        .metadata_only()  // No document changes, just bump schema
    );
}
```

**What happens:**
```bash
$ snugom migrate deploy

[1/1] Running: guilds v2 → v3 (remove_unique_guild_name)

      Dropping unique index...
      DEL snug:myapp:guilds:unique:name

      Updating schema version...
      ████████████████████ 100% (10,000/10,000)

✓ Migration complete
```

---

### Unique Constraint Snapshot Format

The snapshot includes unique constraints:

```json
{
  "entity": "Project",
  "collection": "projects",
  "schema": 2,
  "fields": [
    { "name": "project_id", "type": "String", "id": true },
    { "name": "tenant_id", "type": "String", "filterable": "tag" },
    { "name": "name", "type": "String", "filterable": "tag" }
  ],
  "unique_constraints": [
    {
      "fields": ["tenant_id", "name"],
      "case_insensitive": false
    }
  ],
  "indexes": ["tenant_id", "name"],
  "generated_at": "2024-12-28T17:00:00Z"
}
```

Single-field unique:
```json
{
  "fields": [
    { "name": "name", "type": "String", "filterable": "tag", "unique": true }
  ]
}
```

Case-insensitive unique:
```json
{
  "fields": [
    { "name": "slug", "type": "String", "filterable": "tag", "unique": true, "unique_case_insensitive": true }
  ]
}
```

---

## Migration Types

### Simple Migration (Auto-Generated)

For straightforward changes the CLI fully generates:

| Change | Generated Code |
|--------|----------------|
| Add `Option<T>` field | `doc["field"] = null` |
| Add field with `#[serde(default)]` | `doc["field"] = <default_value>` |
| Remove field | `obj.remove("field")` |
| Add index field | `.add_index_field(...)` + `.rebuild_index()` |
| Remove index field | `.remove_index_field(...)` + `.rebuild_index()` |
| Add unique constraint | `.validate_unique(...)` + `.build_unique_index(...)` |
| Remove unique constraint | `.drop_unique_index(...)` |
| Add compound unique | `.validate_compound_unique(...)` + `.build_compound_unique_index(...)` |

```rust
registry.add(Migration::new("users", 1, 2)
    .transform(|mut doc| {
        doc["new_field"] = json!(null);
        Ok(doc)
    })
);
```

### Metadata-Only Migration

For changes that don't affect document data:

| Change | Example |
|--------|---------|
| Remove has_many relation | Only cascade behavior changes |
| Change cascade policy | Only behavior changes |
| Add relation to existing FK field | Field already exists |

```rust
registry.add(Migration::new("users", 2, 3)
    .metadata_only()  // Just bumps schema, no transform
);
```

### Complex Migration (Full SnugOM Access)

For migrations that need to query, create, or delete entities:

| Scenario | Needs |
|----------|-------|
| Extract embedded to entity | `Repo<T>::create()` |
| Merge entities | `Repo<T>::delete()`, queries |
| Denormalize data | Cross-entity reads |
| Backfill from external source | Custom logic |

```rust
impl ComplexMigration for MyMigration {
    async fn execute(&self, ctx: &mut MigrationContext) -> Result<MigrationStats, MigrationError> {
        let repo: Repo<MyEntity> = ctx.repo();
        // Full SnugOM access!
    }
}
```

---

## Migration Context API

The `MigrationContext` provides everything needed for migrations:

```rust
pub struct MigrationContext {
    executor: RedisExecutor,
    conn: ConnectionManager,
}

impl MigrationContext {
    // === Typed Entity Access ===

    /// Get a typed repo for any registered entity
    pub fn repo<T: SnugomEntity>(&self) -> Repo<T>;

    /// Get executor for repo operations
    pub fn executor(&mut self) -> &mut RedisExecutor;

    // === Raw Document Operations ===

    /// Scan documents in a collection, optionally filtered by schema version
    pub async fn scan_raw(
        &self,
        collection: &str,
        cursor: u64,
        count: usize,
        schema_version: Option<u32>,
    ) -> Result<ScanBatch, MigrationError>;

    /// Update a raw document
    pub async fn update_raw(
        &self,
        collection: &str,
        id: &str,
        doc: Value,
    ) -> Result<(), MigrationError>;

    /// Delete a raw document
    pub async fn delete_raw(
        &self,
        collection: &str,
        id: &str,
    ) -> Result<(), MigrationError>;

    // === Index Operations ===

    /// Create index for a collection
    pub async fn create_index(
        &self,
        collection: &str,
        fields: &[IndexField],
    ) -> Result<(), MigrationError>;

    /// Drop index for a collection
    pub async fn drop_index(
        &self,
        collection: &str,
    ) -> Result<(), MigrationError>;

    /// Rebuild index (drop + create with current schema)
    pub async fn rebuild_index(
        &self,
        collection: &str,
    ) -> Result<(), MigrationError>;

    // === Progress Reporting ===

    /// Report progress for UI
    pub fn progress(&self, current: u64, total: u64);
}

pub struct ScanBatch {
    pub documents: Vec<Value>,
    pub cursor: u64,  // 0 when done
    pub total: u64,   // Total matching documents
}
```

---

## Runtime Schema Validation

The runtime does NOT run migrations. It only validates:

```rust
// In snugom/src/repository.rs

impl<T: SnugomEntity> Repo<T> {
    pub async fn get(
        &self,
        executor: &mut RedisExecutor,
        id: &str,
    ) -> Result<T, RepoError> {
        let doc = self.get_raw(executor, id).await?;

        // Validate schema matches
        let doc_schema = doc["metadata"]["schema"]
            .as_u64()
            .unwrap_or(0) as u32;

        if doc_schema != T::SCHEMA {
            return Err(RepoError::SchemaMismatch {
                entity: T::ENTITY_NAME,
                collection: T::COLLECTION,
                expected: T::SCHEMA,
                found: doc_schema,
            });
        }

        // Deserialize
        serde_json::from_value(doc)
            .map_err(|e| RepoError::Deserialization(e.to_string()))
    }
}
```

**Error when schema mismatch:**
```
Error: Schema mismatch for User in collection 'users'
       Expected schema: 3
       Document schema: 1

       Run `snugom migrate deploy` to migrate documents.
```

---

## File Structure

```
cargo/crates/snugom/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── bin/
│   │   └── snugom/
│   │       ├── main.rs
│   │       └── commands/
│   │           ├── mod.rs
│   │           ├── init.rs
│   │           ├── migrate.rs
│   │           └── schema.rs
│   ├── migration/
│   │   ├── mod.rs
│   │   ├── registry.rs         # MigrationRegistry
│   │   ├── migration.rs        # Migration trait + builders
│   │   ├── complex.rs          # ComplexMigration trait
│   │   ├── context.rs          # MigrationContext
│   │   ├── executor.rs         # Runs migrations
│   │   ├── scanner.rs          # Scans entities from source
│   │   ├── differ.rs           # Compares struct to snapshot
│   │   ├── generator.rs        # Generates migration code
│   │   └── errors.rs           # MigrationError
│   └── ...

# In user's project:
.snugom/
├── config.toml
└── schemas/
    ├── user_v1.json
    ├── user_v2.json
    ├── user_v3.json
    ├── guild_v1.json
    ├── guild_v2.json
    └── guild_member_v1.json

src/migrations/
├── mod.rs                              # Auto-updated by CLI
├── 20241228_100000_init.rs
├── 20241228_110000_add_avatar.rs
├── 20241228_120000_split_name.rs
├── 20241228_130000_add_org_relation.rs
├── 20241228_140000_remove_posts_relation.rs
└── 20241228_150000_extract_guild_members.rs
```

---

## Snapshot Schema

```json
{
  "entity": "User",
  "collection": "users",
  "schema": 3,
  "fields": [
    {
      "name": "user_id",
      "type": "String",
      "id": true
    },
    {
      "name": "first_name",
      "type": "String",
      "filterable": "tag"
    },
    {
      "name": "last_name",
      "type": "String",
      "filterable": "tag"
    },
    {
      "name": "email",
      "type": "String",
      "filterable": "tag"
    },
    {
      "name": "avatar_url",
      "type": "Option<String>"
    },
    {
      "name": "organization_id",
      "type": "Option<String>",
      "filterable": "tag"
    }
  ],
  "relations": [
    {
      "field": "organization_id",
      "target": "organization",
      "kind": "belongs_to",
      "cascade": "detach"
    }
  ],
  "indexes": [
    "first_name",
    "last_name",
    "email",
    "organization_id"
  ],
  "generated_at": "2024-12-28T13:00:00Z",
  "source_file": "src/user/models/domain.rs",
  "source_line": 4
}
```

---

## Auto-Generation Catalog

The CLI auto-generates as many migrations as possible. Below is the complete catalog with examples.

**AUTO** = Fully generated, no edits needed
**STUB** = Skeleton generated with `todo!()`, developer implements logic

---

### AUTO 1: Add Optional Field

**Change:**
```rust
// Before
struct User {
    name: String,
}

// After
struct User {
    name: String,
    bio: Option<String>,  // NEW
}
```

**Generated:**
```rust
.transform(|mut doc| {
    doc["bio"] = json!(null);
    Ok(doc)
})
```

---

### AUTO 2: Add Field with Serde Default

**Change:**
```rust
// After
struct User {
    name: String,
    #[serde(default = "default_role")]
    role: String,  // NEW
}

fn default_role() -> String { "member".to_string() }
```

**Generated:**
```rust
.transform(|mut doc| {
    doc["role"] = json!("member");
    Ok(doc)
})
```

---

### AUTO 3: Add Field with Rust Default

**Change:**
```rust
// After
struct User {
    name: String,
    login_count: u32,  // NEW - no serde default, use Rust's Default
}
```

**Generated:**
```rust
.transform(|mut doc| {
    doc["login_count"] = json!(0);
    Ok(doc)
})
```

**Rust Default Values:**

| Type | Default |
|------|---------|
| `String` | `""` |
| `u8`, `u16`, `u32`, `u64`, `i8`, `i16`, `i32`, `i64` | `0` |
| `f32`, `f64` | `0.0` |
| `bool` | `false` |
| `Vec<T>` | `[]` |
| `Option<T>` | `null` |
| `HashMap<K, V>` | `{}` |

---

### AUTO 4: Add Enum Field

**Change:**
```rust
#[derive(Default)]
enum Status {
    #[default]
    Pending,
    Active,
    Suspended,
}

// After
struct User {
    name: String,
    status: Status,  // NEW
}
```

**Generated:**
```rust
.transform(|mut doc| {
    doc["status"] = json!("Pending");  // Uses #[default] variant
    Ok(doc)
})
```

---

### AUTO 5: Remove Field

**Change:**
```rust
// Before
struct User {
    name: String,
    legacy_id: String,  // REMOVED
    old_status: String, // REMOVED
}

// After
struct User {
    name: String,
}
```

**Generated:**
```rust
.transform(|mut doc| {
    // ⚠️ DATA LOSS WARNING: The following fields are being removed.
    // If you need to preserve or migrate this data, do so before removal.
    //
    // Removed fields:
    //   - legacy_id: String
    //   - old_status: String

    if let Some(obj) = doc.as_object_mut() {
        obj.remove("legacy_id");
        obj.remove("old_status");
    }
    Ok(doc)
})
```

---

### AUTO 6: Add Index (filterable/sortable)

**Change:**
```rust
// Before
struct User {
    name: String,
    email: String,
}

// After
struct User {
    name: String,
    #[snugom(filterable(tag))]  // NEW - add index
    email: String,
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .metadata_only()  // No doc changes
    .add_index_field(IndexField::tag("email"))
    .rebuild_index()
```

---

### AUTO 7: Remove Index

**Change:**
```rust
// Before
struct User {
    #[snugom(filterable(tag))]
    email: String,
}

// After
struct User {
    email: String,  // Index removed
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .metadata_only()
    .remove_index_field("email")
    .rebuild_index()
```

---

### AUTO 8: Change Index Type

**Change:**
```rust
// Before
struct Post {
    #[snugom(filterable(tag))]  // Exact match
    content: String,
}

// After
struct Post {
    #[snugom(filterable(text))]  // Full-text search
    content: String,
}
```

**Generated:**
```rust
Migration::new("posts", 1, 2)
    .metadata_only()
    .change_index_type("content", IndexType::Text)
    .rebuild_index()
```

---

### AUTO 9: Add Unique Constraint

**Change:**
```rust
// Before
struct Guild {
    name: String,
}

// After
struct Guild {
    #[snugom(unique)]
    name: String,
}
```

**Generated:**
```rust
Migration::new("guilds", 1, 2)
    .validate_unique("name", false)
    .on_duplicate(DuplicateAction::Fail)
    .build_unique_index("name", false)
```

---

### AUTO 10: Add Case-Insensitive Unique

**Change:**
```rust
// After
struct User {
    #[snugom(unique(case_insensitive))]
    slug: String,
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .validate_unique("slug", true)  // case_insensitive = true
    .on_duplicate(DuplicateAction::Fail)
    .build_unique_index("slug", true)
```

---

### AUTO 11: Add Compound Unique

**Change:**
```rust
// After
#[snugom(unique_together = ["tenant_id", "name"])]
struct Project {
    tenant_id: String,
    name: String,
}
```

**Generated:**
```rust
Migration::new("projects", 1, 2)
    .validate_compound_unique(&["tenant_id", "name"], false)
    .on_duplicate(DuplicateAction::Fail)
    .build_compound_unique_index(&["tenant_id", "name"], false)
```

---

### AUTO 12: Remove Unique Constraint

**Change:**
```rust
// Before
struct Guild {
    #[snugom(unique)]
    name: String,
}

// After
struct Guild {
    name: String,  // unique removed
}
```

**Generated:**
```rust
Migration::new("guilds", 1, 2)
    .drop_unique_index("name")
    .metadata_only()
```

---

### AUTO 13: Add Relation to Existing Field

**Change:**
```rust
// Before
struct User {
    #[snugom(filterable(tag))]
    organization_id: Option<String>,  // Plain field
}

// After
struct User {
    #[snugom(relation(target = "organization"), filterable(tag))]
    organization_id: Option<String>,  // Now a relation
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .metadata_only()  // Field already exists, just adding relation metadata
```

---

### AUTO 14: Remove has_many Relation

**Change:**
```rust
// Before
struct User {
    #[snugom(relation(target = "post", kind = "has_many", cascade = "delete"))]
    posts: RelationState<Vec<Post>>,
}

// After
struct User {
    // posts relation removed
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .metadata_only()  // has_many not stored in document, just behavior change
```

---

### AUTO 15: Change Cascade Policy

**Change:**
```rust
// Before
struct User {
    #[snugom(relation(target = "post", cascade = "delete"))]
    posts: RelationState<Vec<Post>>,
}

// After
struct User {
    #[snugom(relation(target = "post", cascade = "detach"))]  // Changed
    posts: RelationState<Vec<Post>>,
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .metadata_only()  // Cascade is runtime behavior, not stored in docs
```

---

### AUTO 16: Add belongs_to Relation (New Field)

**Change:**
```rust
// After
struct User {
    name: String,
    #[snugom(relation(target = "organization"), filterable(tag))]
    organization_id: Option<String>,  // NEW field + relation
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .transform(|mut doc| {
        doc["organization_id"] = json!(null);
        Ok(doc)
    })
    .add_index_field(IndexField::tag("organization_id"))
    .rebuild_index()
```

---

### AUTO 17: Add Multiple Fields at Once

**Change:**
```rust
// After
struct User {
    name: String,
    bio: Option<String>,        // NEW
    login_count: u32,           // NEW
    #[snugom(filterable(tag))]
    status: Status,             // NEW with index
}
```

**Generated:**
```rust
Migration::new("users", 1, 2)
    .transform(|mut doc| {
        doc["bio"] = json!(null);
        doc["login_count"] = json!(0);
        doc["status"] = json!("Pending");
        Ok(doc)
    })
    .add_index_field(IndexField::tag("status"))
    .rebuild_index()
```

---

## STUB Cases

These require developer implementation:

### STUB 1: Type Changed

**Why STUB:** CLI can't know conversion logic.

```rust
// Before
struct User {
    age: String,  // "25"
}

// After
struct User {
    age: u32,  // 25
}
```

**Generated Stub:**
```rust
.transform(|mut doc| {
    // TODO: Convert 'age' from String to u32
    //
    // Example:
    //   let age_str = doc.get("age").and_then(|v| v.as_str()).unwrap_or("0");
    //   let age_num: u32 = age_str.parse().unwrap_or(0);
    //   doc["age"] = json!(age_num);

    todo!("Implement migration logic")
})
```

---

### STUB 2: Embedded Array → Separate Entity

**Why STUB:** Requires creating new entities, complex extraction.

```rust
// Before
struct Guild {
    members: Vec<EmbeddedMember>,  // Embedded
}

// After
struct Guild {
    #[snugom(relation(target = "guild_member", kind = "has_many"))]
    members: RelationState<Vec<GuildMember>>,  // Separate entities
}
```

**Generated Stub:**
```rust
impl ComplexMigration for ExtractMembersMigration {
    async fn execute(&self, ctx: &mut MigrationContext) -> Result<MigrationStats, MigrationError> {
        // TODO: Extract embedded members to GuildMember entities
        //
        // Example pattern:
        //   let member_repo: Repo<GuildMember> = ctx.repo();
        //   for guild_doc in ctx.scan_raw("guilds", ...).await? {
        //       for member in guild_doc["members"].as_array()? {
        //           member_repo.create(&mut ctx.executor(), ...).await?;
        //       }
        //       // Remove embedded array from guild
        //   }

        todo!("Implement extraction logic")
    }
}
```

---

## Summary Table

| # | Pattern | Type | Doc Changes | Index Changes |
|---|---------|------|-------------|---------------|
| 1 | Add `Option<T>` field | AUTO | Set to `null` | - |
| 2 | Add field with `#[serde(default)]` | AUTO | Set to serde default | - |
| 3 | Add field (Rust Default) | AUTO | Set to Rust default | - |
| 4 | Add enum field | AUTO | Set to `#[default]` variant | - |
| 5 | Remove field | AUTO | Remove (⚠️ data loss warning) | - |
| 6 | Add index | AUTO | - | Add + rebuild |
| 7 | Remove index | AUTO | - | Remove + rebuild |
| 8 | Change index type | AUTO | - | Change + rebuild |
| 9 | Add unique | AUTO | - | Validate + build |
| 10 | Add unique (case-insensitive) | AUTO | - | Validate + build |
| 11 | Add compound unique | AUTO | - | Validate + build |
| 12 | Remove unique | AUTO | - | Drop |
| 13 | Add relation to existing field | AUTO | - | - |
| 14 | Remove has_many relation | AUTO | - | - |
| 15 | Change cascade policy | AUTO | - | - |
| 16 | Add belongs_to (new field) | AUTO | Set to `null` | Add + rebuild |
| 17 | Multiple fields | AUTO | Combined | Combined |
| - | Type changed | STUB | Developer | Maybe |
| - | Embedded → Entity | STUB | Developer | Developer |

**Note:** Field removal is AUTO but includes a data loss warning. If you need to preserve data (e.g., renaming a field), edit the migration to copy the value before removal.

---

## Comparison to Prisma

| Aspect | Prisma | SnugOM |
|--------|--------|--------|
| **Schema definition** | `schema.prisma` DSL | Rust structs with derive |
| **Change detection** | Diff schema vs DB | Diff struct vs snapshot |
| **Version tracking** | Migration files count | Snapshot files + `#[snugom(schema = N)]` |
| **Explicit version?** | No | No (CLI updates source) |
| **Generate migration** | `prisma migrate dev` | `snugom migrate` |
| **Migration format** | SQL files | Rust files |
| **Apply migration** | `prisma migrate deploy` | `snugom migrate deploy` |
| **Runtime behavior** | Queries fail on mismatch | Error on schema mismatch |
| **Rollback** | `migrate resolve --rolled-back` | `migrate resolve --rolled-back` |
| **Complex migrations** | Manual SQL | Rust with full SnugOM access |
| **Fresh DB setup** | Must run all migrations | No migrations needed |

---

## Implementation Phases

### Phase 1: Core Infrastructure
- [ ] Create snugom CLI binary structure
- [ ] Implement `snugom init` command
- [ ] Define snapshot JSON schema
- [ ] Implement snapshot read/write

### Phase 2: Entity Scanning
- [ ] Parse Rust source files for SnugomEntity structs
- [ ] Extract field information (types, attributes)
- [ ] Extract relation information
- [ ] Extract index information
- [ ] Generate snapshot from parsed struct

### Phase 3: Diff Detection
- [ ] Compare current struct to latest snapshot
- [ ] Detect added/removed/changed fields
- [ ] Detect relation changes
- [ ] Detect index changes
- [ ] Classify migration complexity

### Phase 4: Migration Generation
- [ ] Generate simple migrations (auto-complete)
- [ ] Generate complex migration stubs
- [ ] Update `#[snugom(schema = N)]` in source
- [ ] Update `src/migrations/mod.rs`

### Phase 5: Migration Execution
- [ ] Implement `MigrationContext`
- [ ] Implement simple migration runner
- [ ] Implement complex migration runner
- [ ] Progress reporting
- [ ] Error handling and rollback

### Phase 6: CLI Polish
- [ ] `snugom schema status` command
- [ ] `snugom schema diff` command
- [ ] `snugom migrate resolve` command
- [ ] Colored output and progress bars

### Phase 7: Testing
- [ ] Unit tests for differ
- [ ] Unit tests for generator
- [ ] Integration tests for full workflow
- [ ] Test complex migration scenarios

---

## Success Criteria

1. `snugom migrate` detects all changes automatically
2. Simple migrations are fully auto-generated
3. Complex migrations have helpful stubs with suggestions
4. `snugom migrate deploy` transforms documents correctly
5. Runtime validates schema and errors on mismatch
6. Full SnugOM access in complex migrations
7. Relation changes handled correctly
8. Index changes handled correctly
9. CLI matches snug-api patterns and conventions

---

## Open Questions (Resolved)

| Question | Decision |
|----------|----------|
| Explicit schema version? | No - CLI detects changes and updates source |
| Runtime migration? | No - migrations run separately via CLI |
| Compile-time validation? | No - runtime validation only |
| Rollback support? | Via `resolve --rolled-back` + restore from backup |
| History tracking bloat? | No - snapshots are just files, not compiled |

---

## Sources

- [Prisma Development and Production Workflows](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production)
- [Prisma Mental Model](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model)
- [Prisma Generating Down Migrations](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations)
- [ts-rs TypeScript Generation](https://github.com/Aleph-Alpha/ts-rs)
